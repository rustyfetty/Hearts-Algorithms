{"name":"Hearts: Paranoid vs. Maxn algorithms","tagline":"Paranoid vs. Maxn","body":"# Paranoid vs. Max<sup>n</sup>\r\nTwo common multiplayer algorithms are the paranoid (Sturtevant and Korf, 2000) and the max<sup>n</sup> (Lockhardt and Irani, 1986). The question I have is, which will be better in a game of Hearts?\r\n\r\n## Results\r\nThe graphs below show how my algorithms did after 1,000 games. The average game lasted 11.5 hands, and consists of 13 moves. Each algorithm searches up to 200,000 nodes.\r\n\r\n###Average Scores\r\n![](https://raw.githubusercontent.com/rustyfetty/Hearts-Algorithms/master/Photos/AverageScore.png)\r\nThis graph shows the average score and standard deviation of each algorithm. The paranoid algorithm beats the max<sup>n</sup> by a small margin.\r\n\r\n###Average Speed of Each Move\r\n![](https://raw.githubusercontent.com/rustyfetty/Hearts-Algorithms/master/Photos/MoveSpeed.png)\r\nThe graph shows the average time and standard deviation of the time it took each algorithm to complete its move. It is interesting that during the last five moves the paranoid algorithm becomes faster than the max<sup>n</sup>.\r\n\r\n###Average CPU Time\r\n![](https://raw.githubusercontent.com/rustyfetty/Hearts-Algorithms/master/Photos/AverageCpu.png)\r\nYou can see from the graph that the max<sup>n</sup> is about 1.7 times faster than the paranoid algorithm. This could be due to the simplicity of the way I wrote the max<sup>n</sup> algorithm or the complexity of the paranoid.\r\n\r\n###Statistical Values\r\n![](https://raw.githubusercontent.com/rustyfetty/Hearts-Algorithms/master/Photos/TAndPValues.png)\r\n\r\nFrom the values seen above, we can see that for either of the algorithms vs. a random player, we do not have statistically good probability. We are 97.14% confident in the data we collected for paranoid vs. max<sup>n</sup>, meaning that the paranoid algorithm is slightly better than the max<sup>n</sup>. This is most likely due to the fact that the paranoid algorithm can use alpha-beta pruning to search further than the max<sup>n</sup> algorithm. This is what most of the references that I have linked below suggest. \r\n\r\nI also wonder if it could be a result of the mind-set of each algorithm. On the one hand, you have the paranoid algorithm, which is a defensive player, and on the other you have the max<sup>n</sup> algorithm as an aggressive player. With the paranoid algorithm verses random we have a 91.1% chance of reproducing my results. While this is not considered statically relevant, it is close. This leads me to believe that the paranoid algorithm mind-set of defensiveness is beneficial even in a random environment. If we look at the max<sup>n</sup> algorithm verses random, we only have an 83.1% chance of reproducing the results. This shows me that it is not anywhere near consistent with a random player. I believe this is because the max<sup>n</sup> algorithm is expecting all the other players to think like itself. This makes it unadaptable, and not prepared for players that are outside its own thinking, while the paranoid algorithm's defensiveness makes it ready for those types of moves. I believe this is also another reason the paranoid algorithm is better at the game of Hearts than the max<sup>n</sup> algorithm.\r\n\r\n##Watch It Play\r\n2 Paranoids vs. 2 Max<sup>n</sup>\r\n\r\n<a href=\"http://www.youtube.com/watch?feature=player_embedded&v=GdF2tfNVtck\r\n\" target=\"_blank\"><img src=\"http://img.youtube.com/vi/GdF2tfNVtck/0.jpg\" \r\nalt=\"Algorithms Playing\" width=\"240\" height=\"180\" border=\"10\" /></a>\r\n\r\n## About This Project\r\nThe purpose of this project is to find if the paranoid or max<sup>n</sup> algorithm is the better player at Hearts. The project contains three types of players: paranoid, max<sup>n</sup>, and random. With these three players, I will be able to evaluate the playing capabilities of each algorithm.\r\n\r\nThe max<sup>n</sup> algorithm, created by Lockhardt and Irani, is a tree search-type algorithm. It assumes that all players are trying to maximize their own personal score. The crucial point in writing this algorithm is creating good tie-breaking strategies. The downside to the max<sup>n</sup> algorithm is that it can't easily be pruned.\r\n\r\n###Max<sup>n</sup>\r\n![](https://raw.githubusercontent.com/rustyfetty/Hearts-Algorithms/master/Photos/MaxTree.png)\r\n(The number in each node stands for the player. Each node contains a tuple, where the n<sup>th</sup> item stands for the n<sup>th</sup> player's score.)\r\n\r\nThe paranoid algorithm, created by Sturtevant and Korf, is a minimax algorithm. This algorithm assumes all players are trying to give it the worst score possible, so it must pick a branch that has the best return for itself. The thing that give the paranoid algorithm its edge over the max<sup>n</sup> algorithm is it can use alpha-beta pruning. The downside is if you search too far into the tree, the algorithm can become worse.\r\n\r\n\r\n###Paranoid Tree\r\n![](https://raw.githubusercontent.com/rustyfetty/Hearts-Algorithms/master/Photos/ParanoidTree.png)\r\n(A downward triangle stands for a min player, and an upward triangle stands for a max player. The number in each node stands for the player, and the number outside each node stands for the score that node represents.)\r\n\r\n\r\nThe two algorithms use depth first search on a tree of possible game outcomes. The number of possibilities in the game of hearts limits the depth each algorithm can search. This is where the paranoid algorithm has an advantage of the max<sup>n</sup>, because it can do alpha-beta pruning it can search deeper into the tree.\r\n\r\nTo test these algorithms I recorded the time it took to finish the algorithm, and the average score of each hand that was dealt. The table below shows the brackets in which the algorithms competed. Each bracket consisted of 100 games.\r\n\r\n\r\n### Brackets\r\n![](https://raw.githubusercontent.com/rustyfetty/Hearts-Algorithms/master/Photos/Brackets.png)\r\n\r\nThis table depicts the different algorithms in each game. Each algorithm set played 100 games together. The colors correspond to each algorithm.\r\n\r\n\r\n\r\n## The Reason Why\r\nI wanted to take up this project because most of the good game algorithms are for two-player games. While I don't think I will have any breakthroughs for multiplayer game algorithms, I can find which one of these algorithms is better.\r\n\r\n\r\n## Author\r\nRussell Fetty (@rustyfetty)\r\nThank you to the creator of PyHearts for a platform from which to begin.\r\n\r\n## References\r\nhttp://webdocs.cs.ualberta.ca/~nathanst/papers/comparison_algorithms.pdf\r\nhttps://dke.maastrichtuniversity.nl/m.winands/documents/BestReplySearch.pdf\r\nhttp://www2.cs.uni-paderborn.de/cs/ag-monien/PERSONAL/FLULO/publications/icga_acg.pdf\r\nhttp://neverstopbuilding.com/minimax\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}